from typing import Dict, Any, List, Set, TYPE_CHECKING

from project_control.core.import_parser import extract_imports

if TYPE_CHECKING:
    from project_control.core.content_store import ContentStore


def _should_ignore(path: str, patterns: list[str]) -> bool:
    path_l = path.lower()
    for pattern in patterns:
        if pattern.lower() in path_l:
            return True
    return False


def detect_graph_orphans(
    snapshot: Dict[str, Any],
    patterns: Dict[str, Any],
    content_store: "ContentStore",
    apply_ignore: bool = True,
) -> List[str]:
    """
    Build a static import graph starting from entrypoints.
    Return JS/TS files not reachable from entrypoints.
    
    Args:
        content_store: ContentStore instance for reading file contents without filesystem access.
    """

    entrypoints = patterns.get("entrypoints", [])
    files = snapshot.get("files", [])

    # Filter JS/TS files only
    js_files = [
        f["path"] for f in files
        if f["path"].endswith((".js", ".ts", ".jsx", ".tsx"))
    ]

    ignore_patterns = patterns.get("graph_ignore_patterns", []) if apply_ignore else []
    filtered_files = [
        path for path in js_files
        if not _should_ignore(path, ignore_patterns)
    ]

    js_set = set(filtered_files)

    # Build adjacency map
    graph: Dict[str, Set[str]] = {path: set() for path in filtered_files}

    for f in files:
        path = f["path"]
        if path not in js_set:
            continue

        try:
            content = content_store.get_text(path)
        except Exception:
            continue

        raw_imports = extract_imports(content)

        base_dir = path.rsplit("/", 1)[0] if "/" in path else ""

        for imp in raw_imports:
            # Only resolve relative imports
            if imp.startswith("."):
                # Resolve relative path
                if base_dir:
                    resolved = f"{base_dir}/{imp}"
                else:
                    resolved = imp
                
                # Normalize path
                resolved = resolved.replace("./", "").replace("//", "/")
                
                # Try to match with files in js_set
                for candidate in js_set:
                    candidate_dir = candidate.rsplit("/", 1)[0] if "/" in candidate else ""
                    candidate_name = candidate.rsplit("/", 1)[-1]
                    
                    # Check direct match
                    if candidate == resolved:
                        graph[path].add(candidate)
                    # Check with .js extension
                    elif resolved.endswith(candidate_name):
                        graph[path].add(candidate)
                    # Check with .ts extension
                    elif candidate.replace(".ts", "") == resolved.replace(".js", ""):
                        graph[path].add(candidate)

    # DFS from entrypoints
    reachable: Set[str] = set()

    def dfs(node: str):
        if node in reachable:
            return
        reachable.add(node)
        for neighbor in graph.get(node, []):
            dfs(neighbor)

    for ep in entrypoints:
        if ep in js_set:
            dfs(ep)

    # Graph orphans = JS files not reachable
    return sorted(list(js_set - reachable))