"""Ghost analysis execution and report writing services."""

from __future__ import annotations

from pathlib import Path
from typing import Any, Dict, Optional, TypedDict

from project_control.analysis.tree_renderer import render_tree
from project_control.core.ghost import analyze_ghost
from project_control.core.markdown_renderer import SEVERITY_MAP, render_ghost_report


SECTION_DISPLAY_NAMES = {
    "orphans": "Orphans",
    "legacy": "Legacy snippets",
    "session": "Session files",
    "duplicates": "Duplicates",
}

SECTION_LIMIT_ARGS = {
    "orphans": ("max-high", "max_high"),
    "legacy": ("max-medium", "max_medium"),
    "session": ("max-low", "max_low"),
    "duplicates": ("max-info", "max_info"),
}


class LimitViolation(TypedDict):
    message: str
    exit_code: int


class GhostResult(TypedDict):
    analysis: Dict[str, Any]
    counts: Dict[str, int]
    limit_violation: Optional[LimitViolation]
    deep_report_path: Optional[Path]
    ghost_report_path: Path


def run_ghost(snapshot, patterns, args, snapshot_path: Path) -> GhostResult:
    """
    Execute ghost analysis and validate optional severity thresholds.
    
    Args:
        snapshot: The snapshot dictionary.
        patterns: Configuration patterns.
        args: CLI arguments.
        snapshot_path: Path to snapshot.json for ContentStore.
    """
    analysis = analyze_ghost(snapshot, patterns, snapshot_path, mode=args.mode, deep=args.deep)
    counts = {key: len(analysis.get(key, [])) for key in SECTION_DISPLAY_NAMES}

    limit_violation: Optional[LimitViolation] = None
    for key, label in SECTION_DISPLAY_NAMES.items():
        limit_label, attr_name = SECTION_LIMIT_ARGS[key]
        limit_value = getattr(args, attr_name, -1)
        if limit_value >= 0 and counts[key] > limit_value:
            severity = SEVERITY_MAP.get(key, "INFO")
            limit_violation = {
                "message": f"Ghost limits exceeded: {label}({severity})={counts[key]} > {limit_label}={limit_value}",
                "exit_code": 2,
            }
            break

    return {
        "analysis": analysis,
        "counts": counts,
        "limit_violation": limit_violation,
        "deep_report_path": Path(".project-control") / "exports" / "import_graph_orphans.md" if args.deep else None,
        "ghost_report_path": Path(".project-control") / "exports" / "ghost_candidates.md",
    }


def write_ghost_reports(result: GhostResult, project_root: Path, args) -> None:
    """Write ghost markdown outputs according to CLI options."""
    exports_dir = project_root / ".project-control" / "exports"

    if args.deep:
        graph_report_path = exports_dir / "import_graph_orphans.md"
        graph_orphans = result["analysis"].get("graph_orphans", [])
        graph_lines = [
            "# Import Graph Orphans",
            "",
            "## Legend",
            "(Directory tree based on import graph reachability)",
            "",
            "# NOTE",
            "This report is static-import based.",
            "Dynamic runtime wiring (FrameScheduler, registries, side-effects) is not detected.",
            "",
        ]
        if not args.tree_only:
            for path in graph_orphans:
                graph_lines.append(f"- {path}")
        graph_report_path.write_text("\n".join(graph_lines).rstrip() + "\n", encoding="utf-8")

        if graph_orphans:
            tree_output = render_tree(graph_orphans)
            with graph_report_path.open("a", encoding="utf-8") as f:
                f.write("\n## Tree View\n\n")
                f.write(f"Total import graph orphans: {len(graph_orphans)}\n\n")
                f.write(tree_output)

    ghost_report_path = exports_dir / "ghost_candidates.md"
    render_ghost_report(result["analysis"], str(ghost_report_path))